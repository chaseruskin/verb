// Tests the `alu` module using file IO.

// This interface is automatically @generated by Verb.
// It is not intended for manual editing.
interface alu_bfm
    import sys_defs::*;
#(
  parameter int PHYS_REG_WIDTH
);
    logic clear;
    logic en;
    DATA rs1;
    DATA rs2;
    ALU_FUNC alu_func;
    logic broadcasted;
    logic[PHYS_REG_WIDTH-1:0] dest_tag_in;
    logic dest_tag_wr_en_in;
    DATA result;
    logic next_valid;
    logic ready_next;
    logic[PHYS_REG_WIDTH-1:0] dest_tag_out;
    logic dest_tag_wr_en_out;
endinterface

module alu_tb
    import verb::*;
    import sys_defs::*;
#(
  parameter int PHYS_REG_WIDTH = 6
);

    logic clock = 1'b0;
    logic reset = 1'b0;

    alu_bfm #(
        .PHYS_REG_WIDTH(PHYS_REG_WIDTH)
    ) mdl();

    alu_bfm #(
        .PHYS_REG_WIDTH(PHYS_REG_WIDTH)
    ) bfm();
            
    alu #(
        .PHYS_REG_WIDTH(PHYS_REG_WIDTH)
    ) dut (
        .clock(clock),
        .reset(reset),
        .clear(bfm.clear),
        .en(bfm.en),
        .rs1(bfm.rs1),
        .rs2(bfm.rs2),
        .alu_func(bfm.alu_func),
        .broadcasted(bfm.broadcasted),
        .dest_tag_in(bfm.dest_tag_in),
        .dest_tag_wr_en_in(bfm.dest_tag_wr_en_in),
        .result(bfm.result),
        .next_valid(bfm.next_valid),
        .ready_next(bfm.ready_next),
        .dest_tag_out(bfm.dest_tag_out),
        .dest_tag_wr_en_out(bfm.dest_tag_wr_en_out)
    );

    // produce a clock with an even duty cycle
    always #(20ns) clock = ~clock;

    // drive incoming transactions
    always begin: producer 
        automatic int inputs = $fopen("inputs.txt", "r");

        $dumpfile("alu_tb.vcd");
        $dumpvars(0, alu_tb);

        bfm.broadcasted = 1'b0;

        // reset the module
        sync_hi_async_lo(clock, reset, 4);

        while(!$feof(inputs)) begin
            send(inputs);
            @(negedge clock); #1;
        end
        wait(0);
    end

    // check outgoing transactions for correctness
    always begin: consumer
        automatic int outputs = $fopen("outputs.txt", "r");

        @(negedge reset);
        @(posedge clock);
        while(!$feof(outputs)) begin
            @(negedge clock);
            recv(outputs);
        end
        finish(0);
    end


    // This task is automatically @generated by Verb.
    // It is not intended for manual editing.
    task send(int fd);
        automatic string line;
        // Read next set of input values from file
        if(!$feof(fd)) begin
            $fgets(line, fd);
            $sscanf(parse(line), "%b", bfm.clear);
            $sscanf(parse(line), "%b", bfm.en);
            $sscanf(parse(line), "%b", bfm.rs1);
            $sscanf(parse(line), "%b", bfm.rs2);
            $sscanf(parse(line), "%b", bfm.alu_func);
            $sscanf(parse(line), "%b", bfm.broadcasted);
            $sscanf(parse(line), "%b", bfm.dest_tag_in);
            $sscanf(parse(line), "%b", bfm.dest_tag_wr_en_in);
        end
    endtask


    // This task is automatically @generated by Verb.
    // It is not intended for manual editing.
    task recv(int fd);
        automatic string line;
        // Read expected output values from file
        if(!$feof(fd)) begin
            $fgets(line, fd);
            $sscanf(parse(line), "%b", mdl.result);
            $sscanf(parse(line), "%b", mdl.next_valid);
            $sscanf(parse(line), "%b", mdl.ready_next);
            $sscanf(parse(line), "%b", mdl.dest_tag_out);
            $sscanf(parse(line), "%b", mdl.dest_tag_wr_en_out);
        end
        // Compare received ouputs with expected outputs
        assert_eq(bfm.result, mdl.result, "result");
        assert_eq(bfm.next_valid, mdl.next_valid, "next_valid");
        assert_eq(bfm.ready_next, mdl.ready_next, "ready_next");
        assert_eq(bfm.dest_tag_out, mdl.dest_tag_out, "dest_tag_out");
        assert_eq(bfm.dest_tag_wr_en_out, mdl.dest_tag_wr_en_out, "dest_tag_wr_en_out");
    endtask

endmodule
