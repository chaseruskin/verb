<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Verifying Hardware with Verb</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Verifying Hardware with Verb</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="verifying-hardware-with-verb"><a class="header" href="#verifying-hardware-with-verb">Verifying Hardware with Verb</a></h1>
<p><em>Verb</em> is a simulation-based functional verification framework for digital hardware designs.</p>
<p>Verb leverages <em>file I/O</em> and <em>software programming languages</em> to simulate hardware designs in their native hardware description language.</p>
<p>Verifying hardware with Verb is separated into 3 steps:</p>
<ol>
<li>
<p>Model the hardware design in software to generate input vectors and expected output vectors</p>
</li>
<li>
<p>Simulate the hardware design by sending input vectors to the design under test, receiving output vectors from the design under test, and logging comparisons between simulated output vectors and expected output vectors</p>
</li>
<li>
<p>Analyze the logged comparisons for any errors</p>
</li>
</ol>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<p>The following documentation will be mainly divided into 4 sections:</p>
<ol>
<li><a href="./tutorials/tutorials.html">Tutorials</a> - Step-by-step lessons using Verb</li>
<li><a href="./user/user.html">User Guide</a> - General procedures for "how-to" solve common problems</li>
<li><a href="./topic/topic.html">Topic Guide</a> - Explanations that clarify and provide more detail to particular topics</li>
<li><a href="./reference/reference.html">Reference</a> - Technical information</li>
</ol>
<h2 id="about-the-project"><a class="header" href="#about-the-project">About the Project</a></h2>
<p>The project is open-source under the MIT license and is available on <a href="https://github.com/chaseruskin/verb">GitHub</a>.</p>
<h2 id="about-the-documentation"><a class="header" href="#about-the-documentation">About the Documentation</a></h2>
<p>Documentation system and methodology is inspired by <a href="https://documentation.divio.com">Divio</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="motivation"><a class="header" href="#motivation">Motivation</a></h1>
<p>Hardware is hard. <em>Verifying</em> hardware, forget about it. Unfortunately, you can't just forget about it.</p>
<h2 id="introduction"><a class="header" href="#introduction">Introduction</a></h2>
<p>Verification is an important process in the hardware development cycle that ensures a design functions as intended and is free of bugs. As a design increases in complexity, the number of coding errors also increases. Therefore, one approach to verifying a logic design conforms to specification is <em>functional verification</em>, where tests are performed to check if the design does what is intended under a set of conditions. However, designs typically have an insurmountable amount of test cases that make it impractical to create and perform each one. Therefore, producing test cases and determining when enough test cases is "enough" requires a well-designed and efficient approach.</p>
<h2 id="the-problem"><a class="header" href="#the-problem">The problem</a></h2>
<p>Hardware designs are typically described in hardware description languages (HDLs). These are like the software programming languages of the digital hardware space. To test something in HDLs, one may be inclined to continue to use their HDL to write a model (separate from the design itself) and use that to compare how the design functions during a simulation. However, HDLs are not as nice to write software in because, well, they are focused on describing hardware.</p>
<p>Since digital hardware is at least necessary to write software (think about how your computer is built), digital hardware design can be translated behaviorally up the layers of abstraction to software. Therefore, a more natural option to verifying hardware may be to use software programming languages to write the model, and then test it under a simulation enviornment. Writing the model in software is typically easier with nicer language constructs and an abundance of existing libraries readily available. Writing the model in software also provides an extra layer of cross-checking to ensure the hardware design matches the specification. But, how does one integrate any software programming language with any hardware description language to verify a design's behavior?</p>
<h2 id="the-solution"><a class="header" href="#the-solution">The solution</a></h2>
<p>Enter <em>Verb</em>- a functional verification framework for digital hardware designs.</p>
<p>Verb defines a collection of low-level functions, also known as <em>drivers</em>, that allow a user to communicate between software models and hardware designs for verification. The main form of communication Verb uses to pass data between hardware and software is <em>file I/O</em>. This method was chosen due to its simplicity and wide support in existing HDLs. Drivers are implemented in both the software programming languages and the HDLs to faciliate the interaction between the design and the model.</p>
<p>By using the drivers available through Verb, for every new hardware design users must only focus on writing the model, not configuring the whole testbench.</p>
<p>This framework attempts to decouple the functional and timing aspects of a hardware simulation. The functional model is written in software, while the exact timing of how to monitor and check the design under test is kept in HDL. This separation of layers allows each language to focus in how they are naturally used.</p>
<h2 id="project-goals"><a class="header" href="#project-goals">Project Goals</a></h2>
<p>The following objectives drive the design choices behind building this framework:</p>
<ul>
<li>
<p><strong>ease of use</strong>: Verifying the next design should be intuitive and easy to set up</p>
</li>
<li>
<p><strong>general-purpose</strong>: Be generic and allow the user enough control to support a wide range of designs, from purely combinational logic to control-flow architectures</p>
</li>
<li>
<p><strong>increased productivity</strong>: Using the framework should result in shorter times spent in the verification phase due to reusing highly modular components with insightful results</p>
</li>
</ul>
<h2 id="related-works"><a class="header" href="#related-works">Related Works</a></h2>
<ul>
<li><a href="https://www.cocotb.org">cocotb</a>: coroutine based cosimulation testbench environment for verifying VHDL and SystemVerilog RTL using Python</li>
</ul>
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ul>
<li>https://en.wikipedia.org/wiki/Functional_verification</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installing"><a class="header" href="#installing">Installing</a></h1>
<p>Verb comes in three separate components: a library for software drivers, a library for hardware drivers, and a command-line application for development as well as running pre-simulation and post-simulation processes.</p>
<p>Any of the components may have one or more implementations; install the component in the programming language or HDL you prefer.</p>
<h2 id="software-library"><a class="header" href="#software-library">Software library</a></h2>
<p>The software library provides the driver-level code for writing models.</p>
<h3 id="python"><a class="header" href="#python">Python</a></h3>
<p>Using Pip, run the following command:</p>
<pre><code>pip install git+"https://github.com/chaseruskin/verb.git@trunk#egg=verb"
</code></pre>
<p>To check if it is properly installed, run:</p>
<pre><code>echo "import verb\nprint(verb.__version__)" | python
</code></pre>
<p>The version you installed should print to the console.</p>
<h2 id="hardware-library"><a class="header" href="#hardware-library">Hardware library</a></h2>
<p>The hardware library provides the driver-level code for creating testbenches.</p>
<h3 id="vhdl-systemverilog"><a class="header" href="#vhdl-systemverilog">VHDL, SystemVerilog</a></h3>
<p>Using Orbit, run the following command:</p>
<pre><code>orbit install verb --url "https://github.com/chaseruskin/verb/archive/refs/heads/trunk.zip"
</code></pre>
<p>To check if it is properly installed, run:</p>
<pre><code>orbit view verb --versions
</code></pre>
<p>The version you installed should print to the console.</p>
<h2 id="command-line-application"><a class="header" href="#command-line-application">Command-line application</a></h2>
<p>The command-line application provides commands for faster development and running pre-simulation and post-simulation processes.</p>
<p>Using Cargo, run the following command:</p>
<pre><code>cargo install --git https://github.com/chaseruskin/verb.git
</code></pre>
<p>To check if it is properly installed, run:</p>
<pre><code>verb --version
</code></pre>
<p>The version you installed should print to the console.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tutorials"><a class="header" href="#tutorials">Tutorials</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="user-guide"><a class="header" href="#user-guide">User Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="topic-guide"><a class="header" href="#topic-guide">Topic Guide</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="overview"><a class="header" href="#overview">Overview</a></h1>
<p>The Verb framework is divided into three main layers.</p>
<ul>
<li><em>Software Layer</em>: low-level functions to generate inputs and outputs and analyze recorded data</li>
<li><em>Data Layer</em>: persistent storage of data to be shared between hardware and software layers</li>
<li><em>Hardware Layer</em>: low-level functions to load inputs and outputs, drive inputs, check outputs, and log events</li>
</ul>
<p>This separation of functionality is important for modularity. If a model needs to be written in a different language (Python/C++/Rust), then only the software layer requires changes; the data layer and hardware layer are left unmodified. Having well-defined interfaces between these layers allows for the framework to easily expand to new software languages and HDLs.</p>
<p><img src="topic/./../images/system.svg" alt="" /></p>
<h3 id="software-layer"><a class="header" href="#software-layer">Software Layer</a></h3>
<p>The software layer implements the low-level functions required to run any form of test. It translates your test cases into the data layer represented by a specific file format.</p>
<p>The software layer is responsible for generating test inputs, tracking coverage, and generating test outputs. When defining signals in your software model, you can also specify their probability distribution to randomly sample based on distributions. If not specified, the default is uniform distribution.</p>
<p>The software layer can also generate HDL code, which can be directly copied into the testbench for establishing connections between the hardware design and the data layer.</p>
<p>The software layer is available as a library and as a stand-alone program.</p>
<h3 id="data-layer"><a class="header" href="#data-layer">Data Layer</a></h3>
<p>The data layer stores the tests to run during simulation and the expected outputs. This information is typically stored in a specific file format already handled by Verb.</p>
<p>Each line in a data file is a <em>transaction</em>. A transaction in this sense is the combination of complete set of inputs or outputs. For data stored in an input file, each transaction is to be the input into the design-under-test on a single clock cycle. For data stored in an output file, each transaction is the outputs to be checked against the design-under-test's outputs in the scoreboard. The output transactions do not have to be checked every clock cycle, and may only be cared when a certain condition occurs (such as a valid signal being asserted).</p>
<p>The number of transactions stored as inputs and outputs does not have to be 1-to-1. There may be more input transactions (fed every clock cycle) than output transactions (only checked when valid).</p>
<h3 id="hardware-layer"><a class="header" href="#hardware-layer">Hardware Layer</a></h3>
<p>The hardware drivers implement the low-level functions required to receive data from the data layer. This data is read during simulation to run test cases and automatically assert outputs.</p>
<p>The hardware layer is responsible for the timing of the simulation: specifically determining when to drive inputs and monitoring when to check outputs.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="test-vectors"><a class="header" href="#test-vectors">Test Vectors</a></h1>
<p>One of the key concepts in the Verb framework is using <em>file I/O</em> to communicate data between the software model and the hardware design throughout the verification process. When running the hardware simulation, the testbench receives the information about the inputs and expected outputs by reading files called <em>vectors</em>.</p>
<p><em>Vectors</em> store the test vectors for the hardware design to use- that is, they contain the actual data to either drive as inputs or compare with their outputs.</p>
<p>Typically, the set of input test vectors are written to a file called "inputs.txt", and the set of expected output test vectors are written to a file called "outputs.txt".</p>
<h2 id="vectors-file-format"><a class="header" href="#vectors-file-format">Vectors file format</a></h2>
<p>Each vector is entered on a new line in a vectors file.</p>
<p>A vector uses the following pattern:</p>
<pre><code>&lt;port 1 value&gt; &lt;port 2 value&gt; ...
</code></pre>
<p>Each port value contains a string of 1's and 0's and each port is separated by a single space character. An additional space character follows the final port value.</p>
<p>Example: "inputs.txt"</p>
<pre><code>1 0111 0100 
0 1010 1111 
1 1011 1100 
0 0000 1001
</code></pre>
<p>In this example, we are testing a hardware design that has 3 ports to be driven by the vector file (one port of 1-bit width and two ports of 4-bit width). For this simulation, there are 4 test vectors that will be sent as input to the design over the duration of the simulation.</p>
<p>An empty newline character does not exist at the end of the file. The last line of the file contains the final test vector.</p>
<h2 id="details"><a class="header" href="#details">Details</a></h2>
<p>It is the testbench's responsibility to determine <em>when</em> to actually supply each vector to the hardware design. This approach is taken to provide users with fine-grain control over the timing of the data-flow within the simulation environment.</p>
<p>One of the consequences of having the vectors files have a very simple format allows for easier parsing in the hardware languages. It also means not a lot of additional information is known, such as what order the ports are arranged in each vector.</p>
<p>To check the order of ports that Verb writes to vectors, see the <code class="hljs language-javascript">verb link</code> command. An option is available to print the list of ports in their vector order for inputs and outputs.</p>
<p>A user can also find the port order by identifying the order in which the ports appear in the source code for the hardware design's port interface declarations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage"><a class="header" href="#coverage">Coverage</a></h1>
<p>When verifying hardware, not only is checking <em>what</em> the design generated as outputs important, but also checking <em>how</em> the design generated those outputs is just as important. This tracking of knowledge in <em>how</em> the design reached a set of outputs is known as <em>coverage</em>.</p>
<h3 id="the-importance-of-coverage"><a class="header" href="#the-importance-of-coverage">The importance of coverage</a></h3>
<p>For example, consider we are testing a hardware addition unit. If we run 1,000 test cases and they are all correct, we may be led to believe our design is working perfectly! However, if we discover 500 of these test cases are testing 0+0 = 0 and the remaining 500 test cases are testing 0+1 = 1, that may be a different story. For a 1-bit adder, this might be okay (we covered 2/4 possible input combinations), but if this was a 32-bit adder, we may need to run a lot more tests (there are ${2^{32} * 2^{32} = 2^{64}}$ possible input combinations!). This simple example shows the importance of not just making sure <em>what</em> the design outputs is correct, but also making sure <em>how</em> the test cases sufficiently cover the design's input/state space.</p>
<h3 id="types-of-coverage"><a class="header" href="#types-of-coverage">Types of coverage</a></h3>
<p>There are various forms of coverage. One form of coverage is <em>code coverage</em>, which involves tracking the actual lines of code that have been executed during testing. Another form of coverage is <em>functional coverage</em>, which involves tracking a set of <em>scenarios</em> that have occurred during testing. We define a <em>scenario</em> as a sequence of events that are of interest that set the design into a particular state.</p>
<p>Currently, Verb only supports functional coverage. Users define coverage goals according to a design's coverage specification through coverage nets.</p>
<h2 id="coverage-nets"><a class="header" href="#coverage-nets">Coverage Nets</a></h2>
<p><em>Coverage nets</em> allow the user to specify the coverage scenarios in software by determining how the design can reach a particular scenario and what the design's state should be when that scenario occurs.</p>
<p>The following coverage nets are available in Verb:</p>
<ul>
<li><code class="hljs language-javascript">CoverPoint</code>: Scenarios involving a single state</li>
</ul>
<p>Example scenario: Overflow bit being asserted.</p>
<ul>
<li><code class="hljs language-javascript">CoverRange</code>: Scenarios involving an interval of continuous states</li>
</ul>
<p>Example scenario: All the possible values for a 8-bit input (0-255).</p>
<ul>
<li><code class="hljs language-javascript">CoverGroup</code>: Scenarios involving multiple states</li>
</ul>
<p>Example scenario: The minimum and maximum possible values for a 4-bit input (0 and 15).</p>
<ul>
<li><code class="hljs language-javascript">CoverCross</code>: Scenarios involving the cross product between two or more coverage nets</li>
</ul>
<p>Example scenario: All possible combinations of values for two 8-bit inputs (0-255 x 0-255).</p>
<h2 id="coverage-driven-test-generation-cdtg"><a class="header" href="#coverage-driven-test-generation-cdtg">Coverage-driven test generation (CDTG)</a></h2>
<p>Randomness is good for verification- it increases the confidence in your design that it is robust against all kinds of inputs. However, randomness without constraints may make it difficult for complex designs to enter coverage scenarios in order to meet coverage in as reasonable number of test vectors. Therefore, a form of constrained randomness is ideal for balancing the robustness factor of a design as well as meeting all coverage goals.</p>
<p><em>Coverage-driven test generation</em> (CDTG) is a form of constrained randomness that uses the knowledge of the existing coverage nets to generate the next random test vector within the constraints of advancing toward a currently unmet coverage goal.</p>
<p>Verb supports this form of constrained random test generation by maintaining a list of all the known coverage nets during modeling and assigning the inputs of the model instance with random values that would advance a currently unmet coverage goal.</p>
<h2 id="relating-fishing-to-coverage---an-analogy"><a class="header" href="#relating-fishing-to-coverage---an-analogy">Relating fishing to coverage - an analogy</a></h2>
<p>You can think of functional coverage as fishing in a large open sea. We will first tell the story, and then relate it back to functional coverage.</p>
<h3 id="fishing"><a class="header" href="#fishing">Fishing</a></h3>
<p>Imagine you are the fisherman for your town. Recently you found an old map of an unexplored sea detailiing the locations in the sea of where to find fish, the types of fish, and quantities of fish. This map will be very valuable to your town if you are able to prove that its information is indeed accurate. With the old map as your guide, you embark on your quest.</p>
<p>First, you craft specially designed nets for each location marked on the map to ensure you catch the right types of fish and their corresponding amounts.</p>
<p>Second, you climb aboard your boat and carefully steer it in the right directions to reach the marked locations on the map.</p>
<p>Upon reaching a marked location, you cast that location's specially crafted net. You hope to reach your goal at each marked location by catching the correct amounts and correct types of fish.</p>
<p>After achieving the goals at each marked location in the sea, you return home to tell your town about the successful quest and that the old map is true!</p>
<h3 id="coverage-1"><a class="header" href="#coverage-1">Coverage</a></h3>
<p>There are many parallels between our fishing story and the verification process using functional coverage.</p>
<p>The entire state space of the design can be considered the large unexplored sea. It can be very daunting to try to characterize the entire sea without any form of guidance.</p>
<p>Your main source of guidance during the fishing expedition was the <em>old map</em>, which can be considered the <em>coverage specification</em> in the verification process. The coverage specification details the desired scenarios and how many times they should occur without failure during testing. Specifying <em>what</em> you would like to cover is typically good practice before trying to cover everything, which at many times is impractical for complex designs.</p>
<p>With the knowledge of what locations in the sea are important, you then create your nets for each location. This is the same as using the knowledge of which coverage scenarios are important to then create <em>coverage nets</em>, which formalize the particular scenario in software, how to reach that scenario, and what the design's state should look like during the scenario.</p>
<p>The remaining steps, reaching a marked location and casting the net, may be hard to translate to software. That's where Verb and coverage-driven test generation shines. CDTG essentially steers your boat automatically (with some degree of randomness) and then casts the correct the net once it arrives at the given scenario. Using CTDG can automate the task of arriving at coverage scenarios for currently unmet coverage goals.</p>
<p>Once all coverage goals are met, it is sufficient to say there are no more inputs required to be tested and testing can conclude. At this point, if all tests generated their correct expected values, then the design is successfully verified. Woo-hoo! Time to return home and tell everyone in your town about functional coverage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="events"><a class="header" href="#events">Events</a></h1>
<p>An <em>event</em> is a thing of importance that takes place during hardware simulation. Events are <em>captured</em> during hardware simulation by being written to a log file, typically called "events.log".</p>
<p>There are functions available in the HW libraries for event logging; see the <code class="hljs language-javascript">events</code> package for event logging functions such as <code class="hljs language-javascript">capture(...)</code>, <code class="hljs language-javascript">assert_eq(...)</code>, <code class="hljs language-javascript">monitor(...)</code>, and <code class="hljs language-javascript">stabilize(...)</code>.</p>
<h2 id="event-log-file-format"><a class="header" href="#event-log-file-format">Event log file format</a></h2>
<p>Each event captured during simulation is placed on a new line in the log file.</p>
<p>Each captured event uses the following pattern:</p>
<pre><code>&lt;timestamp&gt; &lt;severity&gt; &lt;topic&gt; &lt;comment&gt;
</code></pre>
<p>Example:</p>
<pre><code>180000000fs         INFO      ASSERT_EQ      sum receives 0110 and expects 0110
</code></pre>
<h3 id="timestamp"><a class="header" href="#timestamp">Timestamp</a></h3>
<p>The timestamp is the time at which the particular event was captured. The value will not include any spaces and may include the time units as a suffix.</p>
<p>Example:</p>
<pre><code>180000000fs
</code></pre>
<h3 id="severity"><a class="header" href="#severity">Severity</a></h3>
<p>The severity is the importance of the captured event. It can only be one of the following values: TRACE, DEBUG, INFO, WARN, ERROR, FATAL.</p>
<p>Example:</p>
<pre><code>INFO
</code></pre>
<p>By default, any events that are of TRACE, DEBUG, or INFO importance are considered <em>OKs</em>. Any events that are of WARN, ERROR, or FATAL importance are considered <em>failures</em>.</p>
<h3 id="topic"><a class="header" href="#topic">Topic</a></h3>
<p>The topic is the high-level thing that is happening in the captured event. The value will not include any spaces and is typically the function name that was called to capture the event.</p>
<p>Example:</p>
<pre><code>ASSERT_EQ
</code></pre>
<h3 id="comment"><a class="header" href="#comment">Comment</a></h3>
<p>The comment is low-level information that is important to this capture event. It is composed of two values: a subject and a predicate.</p>
<pre><code>&lt;subject&gt; &lt;predicate&gt;
</code></pre>
<p>The comment is typically discarded during analysis by Verb and is mainly for the benefit of the user.</p>
<p>Example:</p>
<pre><code>sum receives 0110 and expects 0110
</code></pre>
<h2 id="writing-custom-events"><a class="header" href="#writing-custom-events">Writing custom events</a></h2>
<p>You can easily write custom events by calling the <code class="hljs language-javascript">capture(...)</code> function or by wrapping <code class="hljs language-javascript">capture(...)</code> in another function. It is recommended to write in the present tense when providing values for comments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="reference"><a class="header" href="#reference">Reference</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="python-api"><a class="header" href="#python-api">Python API</a></h1>
<p>The (hopefully complete) list of available functions for the Python programming language. These functions are thought of as the <em>Verb drivers</em> in the framework's software layer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="systemverilog-api"><a class="header" href="#systemverilog-api">SystemVerilog API</a></h1>
<p>Reference documentation for the Verb conjugations in SystemVerilog.</p>
<h2 id="package-verb"><a class="header" href="#package-verb">Package <code class="hljs language-javascript">verb</code></a></h2>
<p><a href="https://github.com/chaseruskin/verb/blob/trunk/src/lib/systemverilog/src/verb.sv">source</a></p>
<h3 id="typedefs"><a class="header" href="#typedefs">Typedefs</a></h3>
<p><code class="hljs language-Verilog">typedef enum {TRACE, DEBUG, INFO, WARN, ERROR, FATAL} tone</code></p>
<p>The log level type.</p>
<br>
<h3 id="functions"><a class="header" href="#functions">Functions</a></h3>
<p><code class="hljs language-Verilog">function automatic int start(input string name)</code></p>
<p>Creates the file with the given <code class="hljs language-javascript">name</code> to prepare for simulation logging.</p>
<br>
<p><code class="hljs language-Verilog">function string parse(inout string row)</code></p>
<p>Return a string in binary format by reading a logic value from the line <code class="hljs language-javascript">row</code>.</p>
<br>
<h3 id="tasks"><a class="header" href="#tasks">Tasks</a></h3>
<p><code class="hljs language-Verilog">task finish(int n=0)</code></p>
<p>Closes the event log file and ends the simulation completely.</p>
<br>
<p><code class="hljs language-Verilog">task automatic async_on_sync_off(ref logic clk, ref logic pin, input logic active, input int cycles)</code></p>
<p>Asynchronous asserts <code class="hljs language-javascript">pin</code> and synchronously de-asserts <code class="hljs language-javascript">pin</code> on the
<code class="hljs language-javascript">cycles</code>'th clock edge.</p>
<br>
<p><code class="hljs language-Verilog">task automatic sync_on_async_off(ref logic clk, ref logic pin, input logic active, input int cycles)</code></p>
<p>Synchronously triggers the logic bit <code class="hljs language-javascript">pin</code> to its state <code class="hljs language-javascript">active</code> and then
asynchronously deactivates the bit to its initial value after <code class="hljs language-javascript">cycles</code>
clock cycles elapse.</p>
<p>The trigger will not be applied if <code class="hljs language-javascript">cycles</code> is set to 0. The signal will
deactivate on the falling edge of the <code class="hljs language-javascript">cycles</code> count clock cycle.</p>
<br>
<p><code class="hljs language-Verilog">task automatic sync_hi_async_lo(ref logic clk, ref logic pin, input int cycles)</code></p>
<p>Synchronously set <code class="hljs language-javascript">pin</code> high, then asynchronously set <code class="hljs language-javascript">pin</code> low.</p>
<br>
<p><code class="hljs language-Verilog">task automatic sync_lo_async_hi(ref logic clk, ref logic pin, input int cycles)</code></p>
<p>Synchronously set <code class="hljs language-javascript">pin</code> low, then asynchronously set <code class="hljs language-javascript">pin</code> high.</p>
<br>
<p><code class="hljs language-Verilog">task automatic async_hi_sync_lo(ref logic clk, ref logic pin, input int cycles)</code></p>
<p>Asynchronously set <code class="hljs language-javascript">pin</code> high, then synchronously set <code class="hljs language-javascript">pin</code> low.</p>
<br>
<p><code class="hljs language-Verilog">task automatic async_lo_sync_hi(ref logic clk, ref logic pin, input int cycles)</code></p>
<p>Asynchronously set <code class="hljs language-javascript">pin</code> low, then synchronously set <code class="hljs language-javascript">pin</code> high.</p>
<br>
<p><code class="hljs language-Verilog">task automatic capture(inout int fd, input tone level, input string topic, input string subject, input string predicate = "")</code></p>
<p>Captures an event during simulation and writes the outcome to the file <code class="hljs language-javascript">fd</code>.</p>
<p>The time when the task is called is recorded in the timestamp.</p>
<br>
<p><code class="hljs language-Verilog">task assert_eq(input logic[4095:0] received, input logic[4095:0] expected, input string subject)</code></p>
<p>Assertion that checks if two logic words <code class="hljs language-javascript">received</code> and <code class="hljs language-javascript">expected</code> are equal to each other.</p>
<p>Note: https://stackoverflow.com/questions/67714329/systemverilog-string-variable-as-format-specifier-for-display-write</p>
<br>
<p><code class="hljs language-Verilog">task assert_ne(input logic[4095:0] received, input logic[4095:0] expected, input string subject)</code></p>
<p>Assertion that checks if two logic words <code class="hljs language-javascript">received</code> and <code class="hljs language-javascript">expected</code> are not equal to each other.</p>
<br>
<p><code class="hljs language-Verilog">task automatic assert_stbl(input bit flag, input logic[4095:0] data, input string subject)</code></p>
<p>Assertion that checks that the behavior of <code class="hljs language-javascript">data</code> is stable while the condition <code class="hljs language-javascript">flag</code> is true (1'b1).</p>
<br>
<p><code class="hljs language-Verilog">task automatic observe(ref logic clk, ref logic flag, input logic active, input int cycles, input string subject)</code></p>
<p>Checks the logic <code class="hljs language-javascript">flag</code> is true (1'b1) on the rising edge of <code class="hljs language-javascript">clk</code> before <code class="hljs language-javascript">cycles</code> clock cycles elapse.</p>
<br>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vhdl-api"><a class="header" href="#vhdl-api">VHDL API</a></h1>
<p>The (hopefully complete) list of available functions for the VHDL hardware description language. These functions are thought of as the <em>Verb drivers</em> in the framework's hardware layer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h1>
<p>A design model written in software may require data from external sources, such as the testbench's interface or the randomness seed. To communicate these values to any design model in any programming language, Verb uses environment variables.</p>
<p>The following environment variables are supported:</p>
<ul>
<li><code class="hljs language-javascript">VERB_TB_JSON</code> â€” The targeted testbench's interface in JSON.</li>
<li><code class="hljs language-javascript">VERB_DUT_JSON</code> - The targeted device-under-test's interface in JSON.</li>
<li><code class="hljs language-javascript">VERB_RAND_SEED</code> - The random seed value.</li>
<li><code class="hljs language-javascript">VERB_EVENTS_FILE</code> - Path to expect the events log.</li>
<li><code class="hljs language-javascript">VERB_COVERAGE_FILE</code> - Path to expect the coverage report.</li>
<li><code class="hljs language-javascript">VERB_LOOP_LIMIT</code> - Maximum number of main loop iterations to perform before forcing a break.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="glossary"><a class="header" href="#glossary">Glossary</a></h1>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
